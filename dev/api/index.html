<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Cliodynamics.jl</title><meta name="title" content="API Reference · Cliodynamics.jl"/><meta property="og:title" content="API Reference · Cliodynamics.jl"/><meta property="twitter:title" content="API Reference · Cliodynamics.jl"/><meta name="description" content="Documentation for Cliodynamics.jl."/><meta property="og:description" content="Documentation for Cliodynamics.jl."/><meta property="twitter:description" content="Documentation for Cliodynamics.jl."/><meta property="og:url" content="https://hyperpolymath.github.io/Cliodynamics.jl/api/"/><meta property="twitter:url" content="https://hyperpolymath.github.io/Cliodynamics.jl/api/"/><link rel="canonical" href="https://hyperpolymath.github.io/Cliodynamics.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Cliodynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/population/">Population Dynamics</a></li><li><a class="tocitem" href="../models/elites/">Elite Dynamics</a></li><li><a class="tocitem" href="../models/instability/">Political Instability</a></li><li><a class="tocitem" href="../models/cycles/">Secular Cycles</a></li><li><a class="tocitem" href="../models/state/">State Formation</a></li><li><a class="tocitem" href="../models/spatial/">Spatial Models</a></li></ul></li><li><a class="tocitem" href="../data/">Data Integration</a></li><li><a class="tocitem" href="../fitting/">Model Fitting</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Indicators"><span>Indicators</span></a></li><li><a class="tocitem" href="#Secular-Cycles"><span>Secular Cycles</span></a></li><li><a class="tocitem" href="#Model-Fitting"><span>Model Fitting</span></a></li><li><a class="tocitem" href="#Data-Integration"><span>Data Integration</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Spatial-Models"><span>Spatial Models</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hyperpolymath/Cliodynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.MalthusianParams"><a class="docstring-binding" href="#Cliodynamics.MalthusianParams"><code>Cliodynamics.MalthusianParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MalthusianParams</code></pre><p>Parameters for basic Malthusian population dynamics model.</p><p><strong>Fields</strong></p><ul><li><code>r::Float64</code>: Intrinsic growth rate (per capita)</li><li><code>K::Float64</code>: Environmental carrying capacity</li><li><code>N0::Float64</code>: Initial population size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L109-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.DemographicStructuralParams"><a class="docstring-binding" href="#Cliodynamics.DemographicStructuralParams"><code>Cliodynamics.DemographicStructuralParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DemographicStructuralParams</code></pre><p>Parameters for Turchin&#39;s demographic-structural theory model.</p><p><strong>Fields</strong></p><ul><li><code>r::Float64</code>: Population growth rate</li><li><code>K::Float64</code>: Carrying capacity</li><li><code>w::Float64</code>: Elite wages relative to common wages</li><li><code>δ::Float64</code>: Elite death/retirement rate</li><li><code>ε::Float64</code>: Elite production rate</li><li><code>N0::Float64</code>: Initial population</li><li><code>E0::Float64</code>: Initial elite population</li><li><code>S0::Float64</code>: Initial state fiscal capacity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L125-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.StateCapacityParams"><a class="docstring-binding" href="#Cliodynamics.StateCapacityParams"><code>Cliodynamics.StateCapacityParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateCapacityParams</code></pre><p>Parameters for state capacity and collective action modeling.</p><p><strong>Fields</strong></p><ul><li><code>τ::Float64</code>: Tax rate</li><li><code>α::Float64</code>: Administrative efficiency</li><li><code>β::Float64</code>: Military effectiveness</li><li><code>γ::Float64</code>: Institutional quality</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L151-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.SecularCyclePhase"><a class="docstring-binding" href="#Cliodynamics.SecularCyclePhase"><code>Cliodynamics.SecularCyclePhase</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SecularCyclePhase</code></pre><p>Enumeration of secular cycle phases according to Turchin-Nefedov model.</p><ul><li><code>Expansion</code>: Population growth, state strengthening, low instability</li><li><code>Stagflation</code>: Population pressure, elite overproduction begins</li><li><code>Crisis</code>: Political instability, state breakdown, social conflict</li><li><code>Depression</code>: Population decline, elite reduction, recovery begins</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L169-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.InstabilityEvent"><a class="docstring-binding" href="#Cliodynamics.InstabilityEvent"><code>Cliodynamics.InstabilityEvent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InstabilityEvent</code></pre><p>Record of a political instability event.</p><p><strong>Fields</strong></p><ul><li><code>year::Int</code>: Year of event</li><li><code>intensity::Float64</code>: Magnitude (0-1 scale)</li><li><code>type::Symbol</code>: Event type (:rebellion, :coup, :revolution, :war)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L186-L195">source</a></section></details></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.malthusian_model"><a class="docstring-binding" href="#Cliodynamics.malthusian_model"><code>Cliodynamics.malthusian_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">malthusian_model(params::MalthusianParams; tspan=(0.0, 100.0))</code></pre><p>Simulate basic Malthusian population dynamics with logistic growth.</p><p>The model follows the differential equation:</p><pre><code class="language-julia hljs">dN/dt = r*N*(1 - N/K)</code></pre><p>where N is population, r is intrinsic growth rate, and K is carrying capacity.</p><p><strong>Arguments</strong></p><ul><li><code>params::MalthusianParams</code>: Model parameters</li><li><code>tspan::Tuple{Float64,Float64}</code>: Time span for simulation (start, end)</li></ul><p><strong>Returns</strong></p><ul><li><code>ODESolution</code>: Solution object containing time series of population</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">params = MalthusianParams(r=0.02, K=1000.0, N0=100.0)
sol = malthusian_model(params, tspan=(0.0, 200.0))
plot(sol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L207-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.demographic_structural_model"><a class="docstring-binding" href="#Cliodynamics.demographic_structural_model"><code>Cliodynamics.demographic_structural_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">demographic_structural_model(params::DemographicStructuralParams; tspan=(0.0, 300.0))</code></pre><p>Simulate Turchin&#39;s demographic-structural theory (DST) model.</p><p>The DST model couples three subsystems:</p><ol><li>Population dynamics with Malthusian pressure</li><li>Elite dynamics with overproduction</li><li>State fiscal capacity and breakdown</li></ol><p><strong>Model Equations</strong></p><pre><code class="language-julia hljs">dN/dt = r*N*(1 - N/K) - conflict_deaths
dE/dt = ε*N - δ*E - elite_conflict
dS/dt = τ*N - α*S - β*instability</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::DemographicStructuralParams</code>: Model parameters</li><li><code>tspan::Tuple{Float64,Float64}</code>: Time span (typically 200-300 years for secular cycles)</li></ul><p><strong>Returns</strong></p><ul><li><code>ODESolution</code>: Solution with [N(t), E(t), S(t)]</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">params = DemographicStructuralParams(
    r=0.015, K=1000.0, w=2.0, δ=0.03, ε=0.001,
    N0=500.0, E0=10.0, S0=100.0
)
sol = demographic_structural_model(params, tspan=(0.0, 300.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L246-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.state_capacity_model"><a class="docstring-binding" href="#Cliodynamics.state_capacity_model"><code>Cliodynamics.state_capacity_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_capacity_model(params::StateCapacityParams, population::Float64, elites::Float64)</code></pre><p>Calculate state capacity from fiscal and institutional parameters.</p><p>State capacity is the ability to implement policy, extract resources, and maintain order. This follows Turchin&#39;s framework incorporating tax revenue, administrative efficiency, and military power.</p><p><strong>Arguments</strong></p><ul><li><code>params::StateCapacityParams</code>: State parameters</li><li><code>population::Float64</code>: Current population</li><li><code>elites::Float64</code>: Current elite population</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: State capacity index</li></ul><p><strong>Formula</strong></p><pre><code class="language-julia hljs">S = α*T + β*M + γ*I</code></pre><p>where T = tax revenue, M = military strength, I = institutional quality</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">params = StateCapacityParams(τ=0.15, α=1.0, β=0.8, γ=0.5)
capacity = state_capacity_model(params, 1000.0, 50.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L628-L656">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.collective_action_problem"><a class="docstring-binding" href="#Cliodynamics.collective_action_problem"><code>Cliodynamics.collective_action_problem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">collective_action_problem(group_size::Int, benefit::Float64, cost::Float64)</code></pre><p>Model collective action problem in state formation.</p><p>Based on Olson&#39;s logic of collective action and Turchin&#39;s application to historical state formation.</p><p><strong>Arguments</strong></p><ul><li><code>group_size::Int</code>: Number of potential contributors</li><li><code>benefit::Float64</code>: Total benefit if collective action succeeds</li><li><code>cost::Float64</code>: Individual cost of participation</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Probability of successful collective action</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Small group, high benefit
prob = collective_action_problem(10, 1000.0, 10.0)  # High probability

# Large group, low benefit
prob = collective_action_problem(1000, 100.0, 1.0)  # Low probability</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L673-L697">source</a></section></details></article><h2 id="Indicators"><a class="docs-heading-anchor" href="#Indicators">Indicators</a><a id="Indicators-1"></a><a class="docs-heading-anchor-permalink" href="#Indicators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.elite_overproduction_index"><a class="docstring-binding" href="#Cliodynamics.elite_overproduction_index"><code>Cliodynamics.elite_overproduction_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">elite_overproduction_index(data::DataFrame)</code></pre><p>Calculate elite overproduction index from historical data.</p><p>Elite overproduction occurs when the supply of elite aspirants exceeds available elite positions, leading to intra-elite competition and political instability.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Must contain columns <code>:year</code>, <code>:population</code>, <code>:elites</code></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Time series with <code>:year</code>, <code>:eoi</code> (Elite Overproduction Index)</li></ul><p><strong>Formula</strong></p><pre><code class="language-julia hljs">EOI = (E/N) / (E/N)_baseline - 1</code></pre><p>where baseline is the mean ratio during stable periods.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    year = 1800:1900,
    population = 100_000:1000:200_000,
    elites = [1000 + 10*i + 5*i^1.5 for i in 0:100]
)
eoi = elite_overproduction_index(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L317-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.political_stress_indicator"><a class="docstring-binding" href="#Cliodynamics.political_stress_indicator"><code>Cliodynamics.political_stress_indicator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">political_stress_indicator(data::DataFrame)</code></pre><p>Calculate Turchin&#39;s Political Stress Indicator (PSI).</p><p>PSI combines three main factors:</p><ol><li>Mass mobilization potential (MMP) - relative wage decline, popular immiseration</li><li>Elite mobilization potential (EMP) - elite overproduction</li><li>State fiscal distress (SFD) - revenue crisis</li></ol><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Must contain <code>:year</code>, <code>:real_wages</code>, <code>:elite_ratio</code>, <code>:state_revenue</code></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Time series with <code>:year</code>, <code>:psi</code>, <code>:mmp</code>, <code>:emp</code>, <code>:sfd</code></li></ul><p><strong>Formula</strong></p><pre><code class="language-julia hljs">PSI = w_mmp*MMP + w_emp*EMP + w_sfd*SFD</code></pre><p>where weights typically are: w<em>mmp=0.4, w</em>emp=0.4, w_sfd=0.2</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    year = 1800:1900,
    real_wages = 100.0 .- (0:100).^1.2,
    elite_ratio = 0.01 .+ (0:100)./5000,
    state_revenue = 1000.0 .- (0:100).^1.5
)
psi_result = political_stress_indicator(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L396-L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.instability_probability"><a class="docstring-binding" href="#Cliodynamics.instability_probability"><code>Cliodynamics.instability_probability</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">instability_probability(psi::Float64)</code></pre><p>Convert Political Stress Indicator to instability event probability.</p><p>Uses logistic transformation based on empirical calibration.</p><p><strong>Arguments</strong></p><ul><li><code>psi::Float64</code>: Political Stress Indicator value</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Probability of instability event (0-1)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">p = instability_probability(0.5)  # Moderate stress</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L450-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.conflict_intensity"><a class="docstring-binding" href="#Cliodynamics.conflict_intensity"><code>Cliodynamics.conflict_intensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conflict_intensity(events::Vector{InstabilityEvent}; window::Int=10)</code></pre><p>Calculate conflict intensity over time from instability events.</p><p><strong>Arguments</strong></p><ul><li><code>events::Vector{InstabilityEvent}</code>: Historical instability events</li><li><code>window::Int</code>: Rolling window size in years</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Time series with <code>:year</code> and <code>:intensity</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">events = [
    InstabilityEvent(1820, 0.3, :rebellion),
    InstabilityEvent(1848, 0.8, :revolution),
    InstabilityEvent(1871, 0.6, :war)
]
intensity = conflict_intensity(events, window=5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L475-L496">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.crisis_threshold"><a class="docstring-binding" href="#Cliodynamics.crisis_threshold"><code>Cliodynamics.crisis_threshold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">crisis_threshold(indicator::Vector{Float64}, percentile::Float64=0.9)</code></pre><p>Determine crisis threshold from historical indicator distribution.</p><p><strong>Arguments</strong></p><ul><li><code>indicator::Vector{Float64}</code>: Historical stress indicator values</li><li><code>percentile::Float64</code>: Percentile to use as threshold (default: 90th)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Threshold value above which indicates crisis</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">psi_values = rand(100)
threshold = crisis_threshold(psi_values, 0.95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L844-L861">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.instability_events"><a class="docstring-binding" href="#Cliodynamics.instability_events"><code>Cliodynamics.instability_events</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">instability_events(data::DataFrame, threshold::Float64)</code></pre><p>Extract instability events from time series based on threshold crossing.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Must contain <code>:year</code> and <code>:indicator</code> columns</li><li><code>threshold::Float64</code>: Threshold value for event detection</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{InstabilityEvent}</code>: Detected events</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(year = 1800:1900, indicator = rand(101))
events = instability_events(data, 0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L866-L883">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.population_pressure"><a class="docstring-binding" href="#Cliodynamics.population_pressure"><code>Cliodynamics.population_pressure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">population_pressure(population::Vector{Float64}, capacity::Float64)</code></pre><p>Calculate population pressure relative to carrying capacity.</p><p><strong>Arguments</strong></p><ul><li><code>population::Vector{Float64}</code>: Population time series</li><li><code>capacity::Float64</code>: Environmental/economic carrying capacity</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Population pressure index (0 = no pressure, 1 = at capacity, &gt;1 = overshoot)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pop = [100.0, 150.0, 200.0, 250.0]
pressure = population_pressure(pop, 200.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L369-L386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.carrying_capacity_estimate"><a class="docstring-binding" href="#Cliodynamics.carrying_capacity_estimate"><code>Cliodynamics.carrying_capacity_estimate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">carrying_capacity_estimate(population::Vector{Float64}, resources::Vector{Float64})</code></pre><p>Estimate historical carrying capacity from population and resource data.</p><p>Uses optimization to find the carrying capacity K that best explains population dynamics under Malthusian constraints.</p><p><strong>Arguments</strong></p><ul><li><code>population::Vector{Float64}</code>: Historical population data</li><li><code>resources::Vector{Float64}</code>: Resource proxy (e.g., agricultural output, GDP)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Estimated carrying capacity</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pop = [100.0, 150.0, 180.0, 195.0, 198.0]
res = [1000.0, 1500.0, 1800.0, 1950.0, 2000.0]
K = carrying_capacity_estimate(pop, res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L808-L829">source</a></section></details></article><h2 id="Secular-Cycles"><a class="docs-heading-anchor" href="#Secular-Cycles">Secular Cycles</a><a id="Secular-Cycles-1"></a><a class="docs-heading-anchor-permalink" href="#Secular-Cycles" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.secular_cycle_analysis"><a class="docstring-binding" href="#Cliodynamics.secular_cycle_analysis"><code>Cliodynamics.secular_cycle_analysis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">secular_cycle_analysis(timeseries::Vector{Float64}; window::Int=50)</code></pre><p>Detect and analyze secular cycles in historical time series.</p><p>Secular cycles are long-term oscillations (150-300 years) in demographic, economic, and political variables. This function uses trend-cycle decomposition and spectral analysis to identify cycle characteristics.</p><p><strong>Arguments</strong></p><ul><li><code>timeseries::Vector{Float64}</code>: Historical data (e.g., population, prices, instability)</li><li><code>window::Int</code>: Window size for moving average detrending</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Contains <code>:trend</code>, <code>:cycle</code>, <code>:period</code>, <code>:amplitude</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Synthetic data with ~200-year cycle
t = 1:300
data = 100 .+ 50*sin.(2π*t/200) .+ 2*randn(300)
analysis = secular_cycle_analysis(data, window=50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L520-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.detect_cycle_phases"><a class="docstring-binding" href="#Cliodynamics.detect_cycle_phases"><code>Cliodynamics.detect_cycle_phases</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">detect_cycle_phases(data::DataFrame)</code></pre><p>Classify secular cycle phases using demographic-structural indicators.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Must contain <code>:year</code>, <code>:population_pressure</code>, <code>:elite_overproduction</code>, <code>:instability</code></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Time series with <code>:year</code> and <code>:phase::SecularCyclePhase</code></li></ul><p><strong>Phase Classification Rules</strong></p><ul><li><strong>Expansion</strong>: Low pressure, low elite competition, low instability</li><li><strong>Stagflation</strong>: High pressure, rising elite competition, moderate instability</li><li><strong>Crisis</strong>: High pressure, high elite competition, high instability</li><li><strong>Depression</strong>: Declining pressure, declining elites, declining instability</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    year = 1500:1800,
    population_pressure = rand(301),
    elite_overproduction = rand(301),
    instability = rand(301)
)
phases = detect_cycle_phases(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L571-L598">source</a></section></details></article><h2 id="Model-Fitting"><a class="docs-heading-anchor" href="#Model-Fitting">Model Fitting</a><a id="Model-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Fitting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.fit_malthusian"><a class="docstring-binding" href="#Cliodynamics.fit_malthusian"><code>Cliodynamics.fit_malthusian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_malthusian(years::Vector{&lt;:Real}, population::Vector{Float64};
               r_init=0.01, K_init=nothing, method=NelderMead())</code></pre><p>Fit Malthusian population model to observed data using Optim.jl.</p><p>Estimates growth rate <code>r</code> and carrying capacity <code>K</code> from historical population time series by minimizing the sum of squared residuals between the ODE solution and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>years::Vector{&lt;:Real}</code>: Observation years</li><li><code>population::Vector{Float64}</code>: Observed population values</li><li><code>r_init</code>: Initial guess for growth rate (default: 0.01)</li><li><code>K_init</code>: Initial guess for carrying capacity (default: 1.2 × max population)</li><li><code>method</code>: Optim.jl optimization method (default: NelderMead())</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Contains <code>:params</code> (MalthusianParams), <code>:loss</code>, <code>:converged</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">years = collect(1800.0:1900.0)
pop = 100.0 .* exp.(0.02 .* (years .- 1800)) ./ (1 .+ (exp.(0.02 .* (years .- 1800)) .- 1) ./ 10)
result = fit_malthusian(years, pop)
println(&quot;Estimated r: &quot;, result.params.r, &quot;, K: &quot;, result.params.K)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L914-L941">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.fit_demographic_structural"><a class="docstring-binding" href="#Cliodynamics.fit_demographic_structural"><code>Cliodynamics.fit_demographic_structural</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_demographic_structural(data::DataFrame; tspan=nothing, method=NelderMead())</code></pre><p>Fit demographic-structural theory model to observed data using Optim.jl.</p><p>Estimates model parameters (r, K, w, δ, ε) from a DataFrame containing <code>:year</code>, <code>:population</code>, <code>:elites</code>, and <code>:state_capacity</code> columns.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Must contain <code>:year</code>, <code>:population</code>, <code>:elites</code>, <code>:state_capacity</code></li><li><code>tspan</code>: Time span override (default: from data year range)</li><li><code>method</code>: Optim.jl optimization method (default: NelderMead())</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Contains <code>:params</code> (DemographicStructuralParams), <code>:loss</code>, <code>:converged</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    year = 1500:1700,
    population = ...,
    elites = ...,
    state_capacity = ...
)
result = fit_demographic_structural(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L971-L997">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.estimate_parameters"><a class="docstring-binding" href="#Cliodynamics.estimate_parameters"><code>Cliodynamics.estimate_parameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_parameters(model_fn, observed::Vector{Float64}, years::Vector{&lt;:Real},
                    initial_params::Vector{Float64};
                    method=NelderMead(), n_bootstrap=100)</code></pre><p>Generic parameter estimation with bootstrap confidence intervals.</p><p>Fits arbitrary model functions to observed data and provides uncertainty estimates via bootstrap resampling.</p><p><strong>Arguments</strong></p><ul><li><code>model_fn</code>: Function <code>(params, years) -&gt; predicted::Vector{Float64}</code></li><li><code>observed::Vector{Float64}</code>: Observed data</li><li><code>years::Vector{&lt;:Real}</code>: Observation times</li><li><code>initial_params::Vector{Float64}</code>: Initial parameter guesses</li><li><code>method</code>: Optim.jl optimization method</li><li><code>n_bootstrap::Int</code>: Number of bootstrap samples for confidence intervals</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Contains <code>:params</code>, <code>:loss</code>, <code>:ci_lower</code>, <code>:ci_upper</code>, <code>:converged</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">model_fn(p, t) = p[1] .* exp.(p[2] .* (t .- t[1]))
result = estimate_parameters(model_fn, observed_data, years, [100.0, 0.01])
println(&quot;95% CI for growth rate: [&quot;, result.ci_lower[2], &quot;, &quot;, result.ci_upper[2], &quot;]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1055-L1082">source</a></section></details></article><h2 id="Data-Integration"><a class="docs-heading-anchor" href="#Data-Integration">Data Integration</a><a id="Data-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Integration" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.load_seshat_csv"><a class="docstring-binding" href="#Cliodynamics.load_seshat_csv"><code>Cliodynamics.load_seshat_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_seshat_csv(filepath::String)</code></pre><p>Load Seshat Global History Databank data from CSV format.</p><p>Reads a CSV file with Seshat-style columns and returns a DataFrame suitable for cliodynamic analysis. Expected columns include NGA (Natural Geographic Area), Polity, Variable, Value, and Date.</p><p>Supports both the standard Seshat export format and simplified tabular format with columns: <code>:year</code>, <code>:polity</code>, <code>:population</code>, <code>:territory</code>, <code>:social_complexity</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: Path to CSV file</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Loaded and cleaned data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = load_seshat_csv(&quot;data/seshat_sample.csv&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1139-L1161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.prepare_seshat_data"><a class="docstring-binding" href="#Cliodynamics.prepare_seshat_data"><code>Cliodynamics.prepare_seshat_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepare_seshat_data(raw::DataFrame; polity::String=&quot;&quot;)</code></pre><p>Convert Seshat-format data into Cliodynamics.jl analysis format.</p><p>Transforms raw Seshat data with columns like <code>:year</code>, <code>:population</code>, <code>:territory</code>, <code>:social_complexity</code> into the format expected by <code>political_stress_indicator</code>, <code>elite_overproduction_index</code>, etc.</p><p><strong>Arguments</strong></p><ul><li><code>raw::DataFrame</code>: Raw Seshat data (from <code>load_seshat_csv</code>)</li><li><code>polity::String</code>: Filter to specific polity (empty string = all)</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Ready for cliodynamic analysis with standardized columns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">raw = load_seshat_csv(&quot;data/seshat_sample.csv&quot;)
data = prepare_seshat_data(raw, polity=&quot;RomPrinwordscp&quot;)
eoi = elite_overproduction_index(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1194-L1216">source</a></section></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.moving_average"><a class="docstring-binding" href="#Cliodynamics.moving_average"><code>Cliodynamics.moving_average</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">moving_average(x::Vector{Float64}, window::Int)</code></pre><p>Calculate moving average for time series smoothing.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: Input time series</li><li><code>window::Int</code>: Window size (must be odd for symmetric smoothing)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Smoothed time series (same length as input)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = randn(100)
smoothed = moving_average(data, 11)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L724-L741">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.detrend"><a class="docstring-binding" href="#Cliodynamics.detrend"><code>Cliodynamics.detrend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">detrend(x::Vector{Float64})</code></pre><p>Remove linear trend from time series.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: Input time series</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Detrended series</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = collect(1:100) .+ randn(100)
detrended = detrend(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L756-L772">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.normalize_timeseries"><a class="docstring-binding" href="#Cliodynamics.normalize_timeseries"><code>Cliodynamics.normalize_timeseries</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">normalize_timeseries(x::Vector{Float64})</code></pre><p>Normalize time series to zero mean and unit variance.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: Input time series</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Normalized series</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = rand(100) .* 100
normalized = normalize_timeseries(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L785-L801">source</a></section></details></article><h2 id="Spatial-Models"><a class="docs-heading-anchor" href="#Spatial-Models">Spatial Models</a><a id="Spatial-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Cliodynamics.spatial_instability_diffusion"><a class="docstring-binding" href="#Cliodynamics.spatial_instability_diffusion"><code>Cliodynamics.spatial_instability_diffusion</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spatial_instability_diffusion(regions, adjacency; diffusion_rate=0.1, tspan=(0.0, 100.0))</code></pre><p>Model instability diffusion across connected regions.</p><p>Each region has its own PSI dynamics, with instability spreading to neighbors via a diffusion term proportional to the PSI difference.</p><p><strong>Arguments</strong></p><ul><li><code>regions::Vector{NamedTuple}</code>: Region parameters, each with <code>:name</code>, <code>:psi0</code> (initial PSI), <code>:growth_rate</code></li><li><code>adjacency::Matrix{Float64}</code>: Adjacency/connectivity matrix (symmetric, 0-1)</li><li><code>diffusion_rate::Float64</code>: Rate of instability diffusion between neighbors (default: 0.1)</li><li><code>tspan::Tuple</code>: Time span for simulation</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>t::Vector{Float64}</code>: Time points</li><li><code>psi::Matrix{Float64}</code>: PSI values (rows=time, cols=regions)</li><li><code>regions::Vector{String}</code>: Region names</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1275-L1294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.territorial_competition_model"><a class="docstring-binding" href="#Cliodynamics.territorial_competition_model"><code>Cliodynamics.territorial_competition_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">territorial_competition_model(states; tspan=(0.0, 200.0))</code></pre><p>Model Lotka-Volterra style territorial competition between states.</p><p>States compete for territory proportional to their military capacity, which depends on population, state capacity, and technology.</p><p><strong>Arguments</strong></p><ul><li><code>states::Vector{NamedTuple}</code>: Each with <code>:name</code>, <code>:territory0</code>, <code>:military</code>, <code>:growth_rate</code></li><li><code>tspan::Tuple</code>: Simulation time span</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>t::Vector{Float64}</code>: Time points</li><li><code>territory::Matrix{Float64}</code>: Territory (rows=time, cols=states)</li><li><code>states::Vector{String}</code>: State names</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1327-L1344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Cliodynamics.frontier_formation_index"><a class="docstring-binding" href="#Cliodynamics.frontier_formation_index"><code>Cliodynamics.frontier_formation_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">frontier_formation_index(cultural_distances, populations, territories)</code></pre><p>Compute the meta-ethnic frontier formation index.</p><p>Based on Turchin&#39;s theory that states form most readily at boundaries between culturally distinct groups (meta-ethnic frontiers).</p><p><strong>Arguments</strong></p><ul><li><code>cultural_distances::Matrix{Float64}</code>: Pairwise cultural distance between groups</li><li><code>populations::Vector{Float64}</code>: Population of each group</li><li><code>territories::Vector{Float64}</code>: Territory of each group</li></ul><p><strong>Returns</strong></p><p><code>Vector{Float64}</code>: Frontier formation index for each group (higher = more likely to form a state)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hyperpolymath/Cliodynamics.jl/blob/894902f21fbd9febe3916ba253be6480715b0344/src/Cliodynamics.jl#L1379-L1394">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 00:57">Friday 13 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
